## 希尔排序
希尔排序是对插入排序的优化。 一下以从小到大排序为例进行说明。

### 1. 插入排序分析

#### 1.1 影响插入排序效率的因素:

* **数据规模**:数据规模越小，效率越高
* **排序前数据的有序性**:排序前原数组的有序性越高，效率越高。当最小的元素位于初始数组的最末尾时，将它插入到正确的位置，需要在它前面的所有元素都向后移动一位。
* 要实现向前移动j位，则需要前面的j个元素都向后移动一位。
    
#### 1.2 提高效率的方式:
  我们可以先对数组进行局部排序，造成数组的有序性，在最后进行统一排序。
* 首先将数组拆分成很m个小数组，对小数组分别排序。在小数组里数据有序性低但是数据规模是小的。
* 不断增大小数组的规模，随着数据规模的不断变大，数组的有序性也增强，性能不会损耗太大，直到小数组变成一个即m=1。完成原始数组的排序。

### 2. 希尔排序

#### 2.1 将大数组拆分成小数组的方式

**在这里，我们比较两种方式**

1. 连续平均分组
    * 即第一次分组:
      ```
      {
        {0,1...k-1},
        {k...2k-1`},
        {`2k...3k-1`},
        {...},
        {(m-1)k,(m-1)k+1,(m-1)k+2...n-1}
      }
      ```
    * 第一次分成m个子数组，在之后的分组方式中，k不断增大，则m不断减小，当k=n时，m=1。
    * 这种分配方式没有解决的问题是，依然是要想向前移动j位，则前面的j个元素都需要向后移动一位。
    
2. 间隔分组
   * 即第一次分组:
    ```
   {
        {0,0+gap,0+2*gap..k*gap},
        {1,1+gap,...1+k*gap},
        {....},
        {gap-1,gap-1+gap,... gap-1+k*gap}
   }
    ```
   * 即间隔性的将数组拆分成了gap个小数组，元素之间间隔位gap,之后不断减小gap,直到gap=1，则完成全部排序。
   * 这种分组方式，满足了优化插入排序的三种要求。这种分配方式中，如果想向前移动gap位，只需要一个元素向后赋值一位即可。

#### 2.2 gap的问题
* gap应该怎样选择？
* gap怎样减小？

通常采用方式初始时gap=n/2,子数组中元素的个数位2个。之后的每次分组中之后gap=gap/2，则子数组中元素变为4，8..每次加倍。直到gap=1.
当然在n/2不能除尽和gap/2不能除尽的情况下，最后一个子数组元素个数可能较少。 这不影响算法性能。

### 3. [代码实现](../../src/ita/chap02/sort_shell.cpp)

### 4. 时间复杂度
* 希尔排序的时间复杂度分析比较复杂，取决于gap的计算方式
* 最坏情况复杂度:O(n<sup>2</sup>)
* 平均时间复杂度:O(n<sup>1.5</sup>)
* 最好情况复杂度:O(n)
* 空间复杂度:O(1)
* 排序方式:`In-place`
* 稳定性:不稳定. 在gap分组的过程中打破了稳定性


